<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[bzoj 2759] 一个动态树好题]]></title>
    <url>%2F2017%2F05%2F18%2Fbzoj-2759-%E4%B8%80%E4%B8%AA%E5%8A%A8%E6%80%81%E6%A0%91%E5%A5%BD%E9%A2%98%2F</url>
    <content type="text"><![CDATA[概述 题解 Description 有$N$个未知数$x_1$~$x_N$和$N$个等式组成的同余方程组：$X_i\equiv{K_i}*{X_{P_i}}+B_i \ \ \ (mod \ 10007)$其中，$ K_i,B_i,X_i\in[0,10007)\bigcap Z $你要应付$Q$个事务，每个是两种情况之一：一.询问当前$x_a$的解$A \ \ a$无解输出$-1$$x_a$有多解输出$-2$否则输出$x_a$二.修改一个等式$C \ \ a \ \ k_a \ \ p_a \ \ b_a$ Solution 同余方程的形式为：$ X_i \equiv {K_i}*{X_{P_i}}+B_i \ \ (mod \ 10007) $也就是说，知道$X_{P_i}$就知道了$X_i$，$X_{P_i}$向$X_i$连一条边 因此$N$个点一共有$N$条边，构成一个基环森林对于环上的点，我们选择一个作为根，其$Fa$称为$SFa$，并断开$Root$与$SFa$的边当且仅当基环树的树根上有$SFa$ 由于需要割边和加边，我们需要用LCT来维护 思考如何求解？如果是一个环的话，我们选择一个点作为起始点，把一次方程依次代入若环上的点有多解，那么树上的点也有多解若环上的点无解，那么树上的点也无解具体做的时候，我们需要在Splay上维护一个系数$K$和常数$B$（维护细节见程序）考虑根到点$i$的序列，设根为第$1$个，$i$为第$N$个，根的$SFa$为$X_0$$X_i = K_1K_2…KnX_0+(B_N+K_NB_{N-1}…+K_{2…N}B_1)$最终得到的应该是$(k-1)x_0+b \equiv 0\ \ (mod \ 10007)$讨论： $k = 0 $ 且 $b \neq 0$无解，输出$-1$ $k = 0 $ 且 $ b = 0 $有多个解，输出$-2$ 整理得$(k-1)x \equiv -b \ \ (mod \ 10007) $，利用拓展欧几里得求解 对于询问 $x$ 我们可以先求出$x$对应的根的$SFa$的值 再Access(x)，Splay(x)，得到对应的系数和常数，从而算出$x$。 对于修改 $x \ y$ 先Cut掉$x$与其父亲的边 然后再连上$x$和$y$的边 $Link$ 如果出现环，就连SFa边 否则Access+Splay连边 $Cut$ 注意是否需要把$SFa$边改成普通边 具体实现细节见程序 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;#define REP(i, a, b) for (int i = (a), i##_end_ = (b); i &lt;= i##_end_; ++i)#define ls(x) ch[x][0]#define rs(x) ch[x][1]const int maxn = 3e4+10, mod = 1e4+7;int n, numk[maxn], numb[maxn], nump[maxn];int ch[maxn][2], fa[maxn], sfa[maxn], par[maxn], vk[maxn], vt[maxn];void Push_Up(int x);void Rotate(int x, int k);void Splay(int x);void Access(int x);int Find_Root(int x);void Link(int x, int y);void Cut(int x);int Query(int x);int solve(int k, int t);int ex_gcd(int a, int b, int &amp;x, int &amp;y);int main()&#123;// freopen("a.in", "r", stdin);// freopen("a.out", "w", stdout); scanf("%d", &amp;n); REP(i, 1, n) &#123; scanf("%d %d %d", &amp;numk[i], &amp;nump[i], &amp;numb[i]); vk[i] = numk[i], vt[i] = numb[i]; &#125; REP(i, 1, n) Link(nump[i], i); int Q, x; char op[5]; scanf("%d", &amp;Q); while (Q --) &#123; scanf("%s %d", op, &amp;x); if (op[0] == 'A') printf("%d\n", Query(x)); else &#123; int k, b, y = Find_Root(x); scanf("%d %d %d", &amp;k, &amp;nump[x], &amp;b); Cut(x); if (x != y &amp;&amp; Find_Root(sfa[y]) != y) Link(sfa[y], y), sfa[y] = 0; Splay(x), numk[x] = k, numb[x] = b; Push_Up(x), Link(nump[x], x); &#125; &#125; return 0;&#125;void Push_Up(int x)&#123; if (!x) return ; vk[x] = numk[x], vt[x] = numb[x]; if (ls(x)) &#123; vk[x] = (vk[x]*vk[ls(x)])%mod; vt[x] = (numk[x]*vt[ls(x)]+vt[x])%mod; &#125; if (rs(x)) &#123; vk[x] = (vk[x]*vk[rs(x)])%mod; vt[x] = (vk[rs(x)]*vt[x]+vt[rs(x)])%mod; &#125;&#125;void Rotate(int x, int k)&#123; int y = fa[x], z = fa[y]; ch[y][k] = ch[x][!k], fa[ch[x][!k]] = y; if (z) ch[z][rs(z) == y] = x; fa[x] = z; ch[x][!k] = y, fa[y] = x; par[x] = par[y], par[y] = 0; Push_Up(y), Push_Up(x);&#125;void Splay(int x)&#123; while (fa[x]) &#123; int y = fa[x], z = fa[y]; if (z == 0) &#123; Rotate(x, rs(y) == x); break ; &#125; int k = rs(z) == y; if (ch[y][k] == x) Rotate(y, k), Rotate(x, k); else Rotate(x, !k), Rotate(x, k); &#125;&#125;void Access(int x)&#123; int y = 0; while (x) &#123; Splay(x); if (rs(x)) fa[rs(x)] = 0, par[rs(x)] = x; rs(x) = y; if (y) fa[y] = x, par[y] = 0; Push_Up(x), y = x, x = par[x]; &#125;&#125;int Find_Root(int x)&#123; Access(x), Splay(x); while (ls(x)) x = ls(x); return x;&#125;void Link(int x, int y)&#123; if (Find_Root(x) == Find_Root(y)) sfa[y] = x; else par[y] = x;&#125;void Cut(int x)&#123; if (sfa[x]) &#123; sfa[x] = 0; return ; &#125; Access(x), Splay(x); if (ls(x)) fa[ls(x)] = 0, ls(x) = 0, Push_Up(x);&#125;int Query(int x)&#123; int y = Find_Root(x), z = sfa[y]; Access(z), Splay(z); int x0 = solve(vk[z]-1, vt[z]); if (x0 &lt; 0) return x0; Access(x), Splay(x); return (x0*vk[x]+vt[x])%mod;&#125;int solve(int k, int t)&#123; if (k == 0 &amp;&amp; t != 0) return -1; if (k == 0 &amp;&amp; t == 0) return -2; int a = (k+mod)%mod, b = mod, c = mod-t%mod, x, y; ex_gcd(a, b, x, y); x = x*c%mod; x = (x+mod)%mod; return x;&#125;int ex_gcd(int a, int b, int &amp;x, int &amp;y)&#123; if (b == 0) &#123; x = 1, y = 0; return a; &#125; int ret = ex_gcd(b, a%b, x, y), temp = x; x = y, y = temp-(a/b)*y; return ret;&#125;]]></content>
      <categories>
        <category>OI生涯</category>
      </categories>
      <tags>
        <tag>动态树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017.5.18]]></title>
    <url>%2F2017%2F05%2F18%2F2017-5-18%2F</url>
    <content type="text"><![CDATA[概述 Hexo+GitHub建站 Markdown学习 Mathjax学习 建站过程 参考1 参考2 环境node.js 上官网下，速度还是可以的git 上官网很慢，去电脑管家下 安装教程里有提到，区别是在Windows的cmd下进行的，Git的怎么都不行但如果能用其中一个，就别换来换去。 写一篇博文看看 申请GitHub基本按着教程来 配置SSH-Key 安装主题主题推荐 hexo基本命令-写博客 主题优化 &amp;&amp; 插件安装参考1-Next主题优化 参考2-Next主题优化 其他问题头像保存：贴图网建议开着VPN Markdown的学习 网上能找到比较不错的教程基本的语法还是比较容易学习的，多练习一下就好了Markdown新手学习 Mathjax的学习 首先先学习了Mathjax的基本语法当然也是在网上找教程：Mathjax新手学习不过Hexo所支持的Mathjax有些不同注意事项： 在markdown中使用mathjax下标时，记得一定要写成\，否则将会出现不能解析的情况。 &amp;打起来特别不舒服，我是用马克飞象的，它总会自动添加后缀，要注意 暂时也就发现了这个，更多的bug再去慢慢探索吧]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>Dairy</tag>
      </tags>
  </entry>
</search>