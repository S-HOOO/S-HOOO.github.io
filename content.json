{"meta":{"title":"hooo's blog","subtitle":"自己选择的路，跪着也要走完","description":"Nothing is impossible!","author":"hooo","url":"http://S-HOOO.github.io"},"pages":[{"title":"关于我","date":"2017-05-18T01:49:41.000Z","updated":"2017-05-18T01:51:56.914Z","comments":true,"path":"about/index.html","permalink":"http://S-HOOO.github.io/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2017-05-18T00:08:40.000Z","updated":"2017-05-18T01:55:54.917Z","comments":true,"path":"categories/index.html","permalink":"http://S-HOOO.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-05-18T00:07:44.000Z","updated":"2017-05-18T01:53:50.681Z","comments":true,"path":"tags/index.html","permalink":"http://S-HOOO.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"[bzoj 2759] 一个动态树好题","slug":"bzoj-2759-一个动态树好题","date":"2017-05-18T12:42:19.000Z","updated":"2017-05-19T01:07:22.717Z","comments":true,"path":"2017/05/18/bzoj-2759-一个动态树好题/","link":"","permalink":"http://S-HOOO.github.io/2017/05/18/bzoj-2759-一个动态树好题/","excerpt":"概述 题解","text":"概述 题解 Description 有$N$个未知数$x_1$~$x_N$和$N$个等式组成的同余方程组：$X_i\\equiv{Ki}*{X{P_i}}+B_i \\ \\ \\ (mod \\ 10007)$其中，$ K_i,B_i,X_i\\in[0,10007)\\bigcap Z $你要应付$Q$个事务，每个是两种情况之一：一.询问当前$x_a$的解$A \\ \\ a$无解输出$-1$$x_a$有多解输出$-2$否则输出$x_a$二.修改一个等式$C \\ \\ a \\ \\ k_a \\ \\ p_a \\ \\ b_a$ Solution 同余方程的形式为：$ X_i \\equiv {Ki}*{X{P_i}}+Bi \\ \\ (mod \\ 10007) $也就是说，知道$X{P_i}$就知道了$Xi$，$X{P_i}$向$X_i$连一条边 因此$N$个点一共有$N$条边，构成一个基环森林对于环上的点，我们选择一个作为根，其$Fa$称为$SFa$，并断开$Root$与$SFa$的边当且仅当基环树的树根上有$SFa$ 由于需要割边和加边，我们需要用LCT来维护 思考如何求解？如果是一个环的话，我们选择一个点作为起始点，把一次方程依次代入若环上的点有多解，那么树上的点也有多解若环上的点无解，那么树上的点也无解具体做的时候，我们需要在Splay上维护一个系数$K$和常数$B$（维护细节见程序）考虑根到点$i$的序列，设根为第$1$个，$i$为第$N$个，根的$SFa$为$X_0$$X_i = K_1K_2…KnX_0+(B_N+KNB{N-1}…+K_{2…N}B_1)$最终得到的应该是$(k-1)x_0+b \\equiv 0\\ \\ (mod \\ 10007)$讨论： $k = 0 $ 且 $b \\neq 0$无解，输出$-1$ $k = 0 $ 且 $ b = 0 $有多个解，输出$-2$ 整理得$(k-1)x \\equiv -b \\ \\ (mod \\ 10007) $，利用拓展欧几里得求解 对于询问 $x$ 我们可以先求出$x$对应的根的$SFa$的值 再Access(x)，Splay(x)，得到对应的系数和常数，从而算出$x$。 对于修改 $x \\ y$ 先Cut掉$x$与其父亲的边 然后再连上$x$和$y$的边 Link 如果出现环，就连SFa边 否则Access+Splay连边 Cut 注意是否需要把$SFa$边改成普通边 具体实现细节见程序 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;#define REP(i, a, b) for (int i = (a), i##_end_ = (b); i &lt;= i##_end_; ++i)#define ls(x) ch[x][0]#define rs(x) ch[x][1]const int maxn = 3e4+10, mod = 1e4+7;int n, numk[maxn], numb[maxn], nump[maxn];int ch[maxn][2], fa[maxn], sfa[maxn], par[maxn], vk[maxn], vt[maxn];void Push_Up(int x);void Rotate(int x, int k);void Splay(int x);void Access(int x);int Find_Root(int x);void Link(int x, int y);void Cut(int x);int Query(int x);int solve(int k, int t);int ex_gcd(int a, int b, int &amp;x, int &amp;y);int main()&#123;// freopen(\"a.in\", \"r\", stdin);// freopen(\"a.out\", \"w\", stdout); scanf(\"%d\", &amp;n); REP(i, 1, n) &#123; scanf(\"%d %d %d\", &amp;numk[i], &amp;nump[i], &amp;numb[i]); vk[i] = numk[i], vt[i] = numb[i]; &#125; REP(i, 1, n) Link(nump[i], i); int Q, x; char op[5]; scanf(\"%d\", &amp;Q); while (Q --) &#123; scanf(\"%s %d\", op, &amp;x); if (op[0] == 'A') printf(\"%d\\n\", Query(x)); else &#123; int k, b, y = Find_Root(x); scanf(\"%d %d %d\", &amp;k, &amp;nump[x], &amp;b); Cut(x); if (x != y &amp;&amp; Find_Root(sfa[y]) != y) Link(sfa[y], y), sfa[y] = 0; Splay(x), numk[x] = k, numb[x] = b; Push_Up(x), Link(nump[x], x); &#125; &#125; return 0;&#125;void Push_Up(int x)&#123; if (!x) return ; vk[x] = numk[x], vt[x] = numb[x]; if (ls(x)) &#123; vk[x] = (vk[x]*vk[ls(x)])%mod; vt[x] = (numk[x]*vt[ls(x)]+vt[x])%mod; &#125; if (rs(x)) &#123; vk[x] = (vk[x]*vk[rs(x)])%mod; vt[x] = (vk[rs(x)]*vt[x]+vt[rs(x)])%mod; &#125;&#125;void Rotate(int x, int k)&#123; int y = fa[x], z = fa[y]; ch[y][k] = ch[x][!k], fa[ch[x][!k]] = y; if (z) ch[z][rs(z) == y] = x; fa[x] = z; ch[x][!k] = y, fa[y] = x; par[x] = par[y], par[y] = 0; Push_Up(y), Push_Up(x);&#125;void Splay(int x)&#123; while (fa[x]) &#123; int y = fa[x], z = fa[y]; if (z == 0) &#123; Rotate(x, rs(y) == x); break ; &#125; int k = rs(z) == y; if (ch[y][k] == x) Rotate(y, k), Rotate(x, k); else Rotate(x, !k), Rotate(x, k); &#125;&#125;void Access(int x)&#123; int y = 0; while (x) &#123; Splay(x); if (rs(x)) fa[rs(x)] = 0, par[rs(x)] = x; rs(x) = y; if (y) fa[y] = x, par[y] = 0; Push_Up(x), y = x, x = par[x]; &#125;&#125;int Find_Root(int x)&#123; Access(x), Splay(x); while (ls(x)) x = ls(x); return x;&#125;void Link(int x, int y)&#123; if (Find_Root(x) == Find_Root(y)) sfa[y] = x; else par[y] = x;&#125;void Cut(int x)&#123; if (sfa[x]) &#123; sfa[x] = 0; return ; &#125; Access(x), Splay(x); if (ls(x)) fa[ls(x)] = 0, ls(x) = 0, Push_Up(x);&#125;int Query(int x)&#123; int y = Find_Root(x), z = sfa[y]; Access(z), Splay(z); int x0 = solve(vk[z]-1, vt[z]); if (x0 &lt; 0) return x0; Access(x), Splay(x); return (x0*vk[x]+vt[x])%mod;&#125;int solve(int k, int t)&#123; if (k == 0 &amp;&amp; t != 0) return -1; if (k == 0 &amp;&amp; t == 0) return -2; int a = (k+mod)%mod, b = mod, c = mod-t%mod, x, y; ex_gcd(a, b, x, y); x = x*c%mod; x = (x+mod)%mod; return x;&#125;int ex_gcd(int a, int b, int &amp;x, int &amp;y)&#123; if (b == 0) &#123; x = 1, y = 0; return a; &#125; int ret = ex_gcd(b, a%b, x, y), temp = x; x = y, y = temp-(a/b)*y; return ret;&#125;","categories":[{"name":"OI生涯","slug":"OI生涯","permalink":"http://S-HOOO.github.io/categories/OI生涯/"}],"tags":[{"name":"动态树","slug":"动态树","permalink":"http://S-HOOO.github.io/tags/动态树/"}]},{"title":"2017.5.18","slug":"2017-5-18","date":"2017-05-18T02:46:41.000Z","updated":"2017-05-18T06:58:46.982Z","comments":true,"path":"2017/05/18/2017-5-18/","link":"","permalink":"http://S-HOOO.github.io/2017/05/18/2017-5-18/","excerpt":"概述 Hexo+GitHub建站 Markdown学习 Mathjax学习","text":"概述 Hexo+GitHub建站 Markdown学习 Mathjax学习 建站经历 选择好的建站教程 这个讲得十分易懂 http://blog.csdn.net/jzooo/article/details/46781805主题推荐 http://www.jianshu.com/p/bcdbe7347c8d Git Bash的问题 网上教程很多，讲得也很详细，但是面临的问题比教程里的多得多第一个问题就是Git Bash，用它根本就不能install hexo试了很多次才发现原来用Windows自带的cmd就可以下载了，于是一直用cmd install npm 组件的问题 在选择主题的时候，很难避免去安装一些npm的组件而国内的网络很多时候会下载失败，需要使用淘宝npm安装 localhost:4000 有一件很奇怪的事情，调着localhost就不行了，不过开着VPN网络也很快 主题选择的问题 hexo的官网很慢，你在上面找主题会累得要死上网找一些推荐的主题，还带安装方法，不过更多的还是要自己去摸索 插件及其他功能 这个应该是最有趣的地方吧，上网到处找有趣的插件 头像问题 方便使用，选择一个存图的网站，方便以后写博 Markdown的学习","categories":[{"name":"建站","slug":"建站","permalink":"http://S-HOOO.github.io/categories/建站/"}],"tags":[{"name":"Dairy","slug":"Dairy","permalink":"http://S-HOOO.github.io/tags/Dairy/"}]},{"title":"2017.5.17","slug":"2017-5-17","date":"2017-05-17T11:33:35.000Z","updated":"2017-05-18T07:06:02.832Z","comments":true,"path":"2017/05/17/2017-5-17/","link":"","permalink":"http://S-HOOO.github.io/2017/05/17/2017-5-17/","excerpt":"摘要：","text":"摘要：正文： $$\\sum_{i=0}^n i^2 = \\frac{(n^2+n)(2n+1)}{6}$$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;#define REP(i, a, b) for (int i = (a), i##_end_ = (b); i &lt;= i##_end_; ++i)#define ls(x) ch[x][0]#define rs(x) ch[x][1]const int maxn = 2e5+10;int n, a[maxn];int ch[maxn][2], sum[maxn], fa[maxn], par[maxn];bool rev[maxn];void Push_Down(int x);void Push_Up(int x);void Rotate(int x, int k);void Splay(int x);void Access(int x);void Evert(int x);void Link(int x, int y);void Cut(int x, int y);int Query(int x);int main()&#123; #ifndef ONLINE_JUDGE freopen(\"a.in\", \"r\", stdin); freopen(\"a.out\", \"w\", stdout); #endif scanf(\"%d\", &amp;n); REP(i, 1, n+1) sum[i] = 1; REP(i, 1, n) &#123; scanf(\"%d\", &amp;a[i]); if (i+a[i] &lt;= n) Link(i+a[i], i); else Link(n+1, i); &#125; int Q; scanf(\"%d\", &amp;Q); while (Q --) &#123; int ty, x, k; scanf(\"%d %d\", &amp;ty, &amp;x); x ++; if (ty == 1) printf(\"%d\\n\", Query(x)); else &#123; scanf(\"%d\", &amp;k); if (x+a[x] &lt;= n) Cut(x+a[x], x); else Cut(n+1, x); a[x] = k; if (x+a[x] &lt;= n) Link(x+a[x], x); else Link(n+1, x); &#125; &#125; return 0;&#125;void Push_Down(int x)&#123; if (!x || !rev[x]) return ; rev[x] = 0, swap(ls(x), rs(x)); if (ls(x)) rev[ls(x)] ^= 1; if (rs(x)) rev[rs(x)] ^= 1;&#125;void Push_Up(int x)&#123; if (!x) return ; sum[x] = 1; if (ls(x)) sum[x] += sum[ls(x)]; if (rs(x)) sum[x] += sum[rs(x)];&#125;void Rotate(int x, int k)&#123; int y = fa[x], z = fa[y]; ch[y][k] = ch[x][!k], fa[ch[x][!k]] = y; if (z) ch[z][rs(z) == y] = x; fa[x] = z; ch[x][!k] = y, fa[y] = x; par[x] = par[y], par[y] = 0; Push_Up(y), Push_Up(x);&#125;int sta[maxn];void Splay(int x)&#123; int s_cnt = 0; sta[++s_cnt] = x; while (fa[sta[s_cnt]]) sta[++s_cnt] = fa[sta[s_cnt-1]]; while (s_cnt) Push_Down(sta[s_cnt--]); while (fa[x]) &#123; int y = fa[x], z = fa[y]; if (z == 0) &#123; Rotate(x, rs(y) == x); break ; &#125; int k = rs(z) == y; if (ch[y][k] == x) Rotate(y, k), Rotate(x, k); else Rotate(x, !k), Rotate(x, k); &#125;&#125;void Access(int x)&#123; int y = 0; while (x) &#123; Splay(x); if (rs(x)) fa[rs(x)] = 0, par[rs(x)] = x; rs(x) = y; if (y) fa[y] = x, par[y] = 0; Push_Up(x), y = x, x = par[x]; &#125;&#125;void Evert(int x)&#123; Access(x), Splay(x), rev[x] ^= 1;&#125;void Link(int x, int y)&#123; Evert(y), Splay(y), par[y] = x;&#125;void Cut(int x, int y)&#123; Evert(x), Access(y), Splay(y); if (ls(y)) fa[ls(y)] = 0, ls(y) = 0; Push_Up(y);&#125;int Query(int x)&#123; Evert(n+1), Access(x), Splay(x); return sum[ls(x)];&#125;","categories":[{"name":"OI生涯","slug":"OI生涯","permalink":"http://S-HOOO.github.io/categories/OI生涯/"}],"tags":[{"name":"Dairy","slug":"Dairy","permalink":"http://S-HOOO.github.io/tags/Dairy/"}]}]}