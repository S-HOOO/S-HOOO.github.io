{"meta":{"title":"hooo's blog","subtitle":"自己选择的路，跪着也要走完","description":"Nothing is impossible!","author":"hooo","url":"http://S-HOOO.github.io"},"pages":[{"title":"关于我","date":"2017-05-18T01:49:41.000Z","updated":"2017-05-18T01:51:56.914Z","comments":true,"path":"about/index.html","permalink":"http://S-HOOO.github.io/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2017-05-18T00:08:40.000Z","updated":"2017-05-18T01:55:54.917Z","comments":true,"path":"categories/index.html","permalink":"http://S-HOOO.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-05-18T00:07:44.000Z","updated":"2017-05-18T01:53:50.681Z","comments":true,"path":"tags/index.html","permalink":"http://S-HOOO.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"BestCoder Round #93","slug":"BestCoder-Round-93","date":"2017-05-19T11:00:55.000Z","updated":"2017-05-19T12:25:58.750Z","comments":true,"path":"2017/05/19/BestCoder-Round-93/","link":"","permalink":"http://S-HOOO.github.io/2017/05/19/BestCoder-Round-93/","excerpt":"##概述 题解","text":"##概述 题解 MG loves goldDescription 有n个数，要你分出连续的段，使得每段内的数互不相同，求最小的段数 范围：1e5 多组数据 Solution 离散化，然后扫一遍，统计同种数的数目即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;#define REP(i, a, b) for (int i = (a), i##_end_ = (b); i &lt;= i##_end_; ++i)#define mset(a, b) memset(a, b, sizeof(a))const int maxn = 1e5+10;int n, a[maxn], b[maxn];int sum[maxn];int main()&#123; int T; scanf(\"%d\", &amp;T); while (T --) &#123; scanf(\"%d\", &amp;n); REP(i, 1, n) scanf(\"%d\", &amp;a[i]), b[i] = a[i]; sort(b+1, b+n+1); int t_cnt = unique(b+1, b+n+1)-b-1; REP(i, 1, n) a[i] = lower_bound(b+1, b+t_cnt+1, a[i])-b; mset(sum, 0); int j = 0, ans = 1; REP(i, 1, n) if (sum[a[i]]+1 == 2) &#123; REP(k, j+1, i-1) sum[a[k]] --; sum[a[i]] ++; ans ++, j = i-1; &#125; else sum[a[i]] ++; printf(\"%d\\n\", ans); &#125; return 0;&#125; MG loves appleDescription&emsp;有n个数，每个数的范围是0~9，组成一个n位数。问恰好去掉这个n位数中的k位，是否存在一个方案，使得剩下的位所表示的合法数字是3的倍数。（合法数字即不含前导零，但单独一个零是合法的）&emsp;范围：$1\\leq n \\leq 1e5$ 多组数据 Solution&emsp;一个数是3的倍数当且仅当这个数的每一位的数字的和是3的倍数&emsp;也就是说，题目所给出的0~9是假的，其实只有0、1、2三位&emsp;要怎么满足恰好去掉K位呢？&emsp;看到数只有3位，其实是可以分类讨论的。&emsp;我们先枚举i为第一个要保留的数位，设$cnt[i][j]$为模3等于j的数的个数的后缀和&emsp;前$i-1$位必定删去，那么就要在后面删去$k-(i-1)$位，设$d = k-(i-1)$&emsp;设$t = (a_i+a_{i+1}..a_n)\\%3$，那么后面删去的d位的和模3等于t&emsp;由于模3等于0对值不会有影响，只要考虑1和2就好了&emsp;由于做了后缀和，可知$k1\\%3 = 0,1,2$中满足限制k的最大值，k2同理&emsp;枚举余数之间的组合，直接判断可行性即可，细节见程序 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;#define REP(i, a, b) for (int i = (a), i##_end_ = (b); i &lt;= i##_end_; ++i)#define DWN(i, a, b) for (int i = (a), i##_end_ = (b); i &gt;= i##_end_; --i)#define mcpy(a, b) memcpy(a, b, sizeof(b))#define mset(a, b) memset(a, b, sizeof(a))const int maxn = 1e5+10;int n, k, a[maxn], cnt[maxn][3];char str[maxn];bool solve(int ta, int tb, int tc, int t, int tk);int main()&#123; freopen(\"a.in\", \"r\", stdin); freopen(\"a.out\", \"w\", stdout); int T; scanf(\"%d\", &amp;T); while (T --) &#123; scanf(\"%d %d\", &amp;n, &amp;k); scanf(\"%s\", str+1); REP(i, 1, n) a[i] = (str[i]-'0')%3; mset(cnt[n+1], 0);//记得初始化 DWN(i, n, 1) &#123; mcpy(cnt[i], cnt[i+1]); cnt[i][a[i]] ++; &#125; bool check = false; REP(i, 1, n) &#123; if (str[i] == '0') continue ; int t = (cnt[i][1]+cnt[i][2]*2)%3; cnt[i][a[i]] --; int ta = cnt[i][0], tb = cnt[i][1], tc = cnt[i][2]; if (k-(i-1) &lt; 0) break ;//可行性 if (solve(ta, tb, tc, t, k-(i-1))) &#123; check = true; break ; &#125; &#125; if (k == n-1 &amp;&amp; !check)//特判只有一个零的情况 REP(i, 1, n) if (str[i] == '0') &#123; check = true; break ; &#125; if (check) puts(\"yes\"); else puts(\"no\"); &#125; return 0;&#125;bool solve(int ta, int tb, int tc, int t, int tk)&#123; int b[3], c[3], lim_b[3], lim_c[3]; lim_b[0] = 0, lim_b[1] = 1, lim_b[2] = 2; lim_c[0] = 0, lim_c[1] = 2, lim_c[2] = 1; b[0] = b[1] = b[2] = c[0] = c[1] = c[2] = -1; REP(i, 0, 2) &#123; if (tb-i &lt; 0) break ; int s = (tb-i)%3; b[s] = tb-i; &#125; REP(i, 0, 2) &#123; if (tc-i &lt; 0) break ; int s = (tc-i)*2%3; c[s] = tc-i; &#125; REP(i, 0, 2) REP(j, 0, 2) &#123; if (b[i] == -1 || c[j] == -1) continue ; if (i &amp;&amp; b[i] == 0 || j &amp;&amp; c[j] == 0) continue ; if ((i+j)%3 != t) continue ;//可行性 if (b[i]+c[j] &gt;= tk) REP(d, 0, 2) &#123; if (ta &lt; d || tk &lt; d) break ; if ((b[i]+c[j]-(tk-d))%3 == 0 &amp;&amp; lim_b[i]+lim_c[j] &lt;= (tk-d)) //可行性 return true; &#125; else if (tk-b[i]-c[j] &lt;= ta) return true; &#125; return false;&#125;","categories":[{"name":"Oi生涯","slug":"Oi生涯","permalink":"http://S-HOOO.github.io/categories/Oi生涯/"}],"tags":[{"name":"比赛 \\ Bestcoder","slug":"比赛-Bestcoder","permalink":"http://S-HOOO.github.io/tags/比赛-Bestcoder/"}]},{"title":"[bzoj 2759] 一个动态树好题","slug":"bzoj-2759-一个动态树好题","date":"2017-05-18T12:42:19.000Z","updated":"2017-05-19T06:34:02.494Z","comments":true,"path":"2017/05/18/bzoj-2759-一个动态树好题/","link":"","permalink":"http://S-HOOO.github.io/2017/05/18/bzoj-2759-一个动态树好题/","excerpt":"概述 题解","text":"概述 题解 Description 有$N$个未知数$x_1$~$x_N$和$N$个等式组成的同余方程组：$X_i\\equiv{K_i}*{X_{P_i}}+B_i \\ \\ \\ (mod \\ 10007)$其中，$ K_i,B_i,X_i\\in[0,10007)\\bigcap Z $你要应付$Q$个事务，每个是两种情况之一：一.询问当前$x_a$的解$A \\ \\ a$无解输出$-1$$x_a$有多解输出$-2$否则输出$x_a$二.修改一个等式$C \\ \\ a \\ \\ k_a \\ \\ p_a \\ \\ b_a$ Solution 同余方程的形式为：$ X_i \\equiv {K_i}*{X_{P_i}}+B_i \\ \\ (mod \\ 10007) $也就是说，知道$X_{P_i}$就知道了$X_i$，$X_{P_i}$向$X_i$连一条边 因此$N$个点一共有$N$条边，构成一个基环森林对于环上的点，我们选择一个作为根，其$Fa$称为$SFa$，并断开$Root$与$SFa$的边当且仅当基环树的树根上有$SFa$ 由于需要割边和加边，我们需要用LCT来维护 思考如何求解？如果是一个环的话，我们选择一个点作为起始点，把一次方程依次代入若环上的点有多解，那么树上的点也有多解若环上的点无解，那么树上的点也无解具体做的时候，我们需要在Splay上维护一个系数$K$和常数$B$（维护细节见程序）考虑根到点$i$的序列，设根为第$1$个，$i$为第$N$个，根的$SFa$为$X_0$$X_i = K_1K_2…KnX_0+(B_N+K_NB_{N-1}…+K_{2…N}B_1)$最终得到的应该是$(k-1)x_0+b \\equiv 0\\ \\ (mod \\ 10007)$讨论： $k = 0 $ 且 $b \\neq 0$无解，输出$-1$ $k = 0 $ 且 $ b = 0 $有多个解，输出$-2$ 整理得$(k-1)x \\equiv -b \\ \\ (mod \\ 10007) $，利用拓展欧几里得求解 对于询问 $x$ 我们可以先求出$x$对应的根的$SFa$的值 再Access(x)，Splay(x)，得到对应的系数和常数，从而算出$x$。 对于修改 $x \\ y$ 先Cut掉$x$与其父亲的边 然后再连上$x$和$y$的边 $Link$ 如果出现环，就连SFa边 否则Access+Splay连边 $Cut$ 注意是否需要把$SFa$边改成普通边 具体实现细节见程序 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;#define REP(i, a, b) for (int i = (a), i##_end_ = (b); i &lt;= i##_end_; ++i)#define ls(x) ch[x][0]#define rs(x) ch[x][1]const int maxn = 3e4+10, mod = 1e4+7;int n, numk[maxn], numb[maxn], nump[maxn];int ch[maxn][2], fa[maxn], sfa[maxn], par[maxn], vk[maxn], vt[maxn];void Push_Up(int x);void Rotate(int x, int k);void Splay(int x);void Access(int x);int Find_Root(int x);void Link(int x, int y);void Cut(int x);int Query(int x);int solve(int k, int t);int ex_gcd(int a, int b, int &amp;x, int &amp;y);//123int main()&#123; freopen(\"a.in\", \"r\", stdin); freopen(\"a.out\", \"w\", stdout); scanf(\"%d\", &amp;n); REP(i, 1, n) &#123; scanf(\"%d %d %d\", &amp;numk[i], &amp;nump[i], &amp;numb[i]); vk[i] = numk[i], vt[i] = numb[i]; &#125; REP(i, 1, n) Link(nump[i], i); int Q, x; char op[5]; scanf(\"%d\", &amp;Q); while (Q --) &#123; scanf(\"%s %d\", op, &amp;x); if (op[0] == 'A') printf(\"%d\\n\", Query(x)); else &#123; int k, b, y = Find_Root(x); scanf(\"%d %d %d\", &amp;k, &amp;nump[x], &amp;b); Cut(x); if (x != y &amp;&amp; Find_Root(sfa[y]) != y) Link(sfa[y], y), sfa[y] = 0; Splay(x), numk[x] = k, numb[x] = b; Push_Up(x), Link(nump[x], x); &#125; &#125; return 0;&#125;void Push_Up(int x)&#123; if (!x) return ; vk[x] = numk[x], vt[x] = numb[x]; if (ls(x)) &#123; vk[x] = (vk[x]*vk[ls(x)])%mod; vt[x] = (numk[x]*vt[ls(x)]+vt[x])%mod; &#125; if (rs(x)) &#123; vk[x] = (vk[x]*vk[rs(x)])%mod; vt[x] = (vk[rs(x)]*vt[x]+vt[rs(x)])%mod; &#125;&#125;void Rotate(int x, int k)&#123; int y = fa[x], z = fa[y]; ch[y][k] = ch[x][!k], fa[ch[x][!k]] = y; if (z) ch[z][rs(z) == y] = x; fa[x] = z; ch[x][!k] = y, fa[y] = x; par[x] = par[y], par[y] = 0; Push_Up(y), Push_Up(x);&#125;void Splay(int x)&#123; while (fa[x]) &#123; int y = fa[x], z = fa[y]; if (z == 0) &#123; Rotate(x, rs(y) == x); break ; &#125; int k = rs(z) == y; if (ch[y][k] == x) Rotate(y, k), Rotate(x, k); else Rotate(x, !k), Rotate(x, k); &#125;&#125;void Access(int x)&#123; int y = 0; while (x) &#123; Splay(x); if (rs(x)) fa[rs(x)] = 0, par[rs(x)] = x; rs(x) = y; if (y) fa[y] = x, par[y] = 0; Push_Up(x), y = x, x = par[x]; &#125;&#125;int Find_Root(int x)&#123; Access(x), Splay(x); while (ls(x)) x = ls(x); return x;&#125;void Link(int x, int y)&#123; if (Find_Root(x) == Find_Root(y)) sfa[y] = x; else par[y] = x;&#125;void Cut(int x)&#123; if (sfa[x]) &#123; sfa[x] = 0; return ; &#125; Access(x), Splay(x); if (ls(x)) fa[ls(x)] = 0, ls(x) = 0, Push_Up(x);&#125;int Query(int x)&#123; int y = Find_Root(x), z = sfa[y]; Access(z), Splay(z); int x0 = solve(vk[z]-1, vt[z]); if (x0 &lt; 0) return x0; Access(x), Splay(x); return (x0*vk[x]+vt[x])%mod;&#125;int solve(int k, int t)&#123; if (k == 0 &amp;&amp; t != 0) return -1; if (k == 0 &amp;&amp; t == 0) return -2; int a = (k+mod)%mod, b = mod, c = mod-t%mod, x, y; ex_gcd(a, b, x, y); x = x*c%mod; x = (x+mod)%mod; return x;&#125;int ex_gcd(int a, int b, int &amp;x, int &amp;y)&#123; if (b == 0) &#123; x = 1, y = 0; return a; &#125; int ret = ex_gcd(b, a%b, x, y), temp = x; x = y, y = temp-(a/b)*y; return ret;&#125;","categories":[{"name":"OI生涯","slug":"OI生涯","permalink":"http://S-HOOO.github.io/categories/OI生涯/"}],"tags":[{"name":"动态树","slug":"动态树","permalink":"http://S-HOOO.github.io/tags/动态树/"}]},{"title":"2017.5.18","slug":"2017-5-18","date":"2017-05-18T02:46:41.000Z","updated":"2017-05-19T02:23:26.435Z","comments":true,"path":"2017/05/18/2017-5-18/","link":"","permalink":"http://S-HOOO.github.io/2017/05/18/2017-5-18/","excerpt":"概述 Hexo+GitHub建站 Markdown学习 Mathjax学习","text":"概述 Hexo+GitHub建站 Markdown学习 Mathjax学习 建站过程 参考1 参考2 环境node.js 上官网下，速度还是可以的git 上官网很慢，去电脑管家下 安装教程里有提到，区别是在Windows的cmd下进行的，Git的怎么都不行但如果能用其中一个，就别换来换去。 写一篇博文看看 申请GitHub基本按着教程来 配置SSH-Key 安装主题主题推荐 hexo基本命令-写博客 主题优化 &amp;&amp; 插件安装参考1-Next主题优化 参考2-Next主题优化 其他问题头像保存：贴图网建议开着VPN Markdown的学习 网上能找到比较不错的教程基本的语法还是比较容易学习的，多练习一下就好了Markdown新手学习 Mathjax的学习 首先先学习了Mathjax的基本语法当然也是在网上找教程：Mathjax新手学习不过Hexo所支持的Mathjax有些不同注意事项： 在markdown中使用mathjax下标时，记得一定要写成\\，否则将会出现不能解析的情况。 &amp;打起来特别不舒服，我是用马克飞象的，它总会自动添加后缀，要注意 暂时也就发现了这个，更多的bug再去慢慢探索吧","categories":[{"name":"建站","slug":"建站","permalink":"http://S-HOOO.github.io/categories/建站/"}],"tags":[{"name":"Dairy","slug":"Dairy","permalink":"http://S-HOOO.github.io/tags/Dairy/"}]}]}